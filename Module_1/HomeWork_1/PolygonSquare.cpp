#include "bits/stdc++.h"

/*
 *  Вычислить площадь выпуклого n-угольника, заданного координатами своих вершин. Вначале вводится количество вершин, затем последовательно целочисленные координаты всех вершин в порядке обхода против часовой стрелки.
 *  n < 1000, координаты < 10000.
 *  Указание. Для вычисления площади n-угольника можно посчитать сумму ориентированных площадей трапеций под каждой стороной многоугольника.
 */

double midline(double a, double b) { return (a + b) / 2; }

struct Point {
  double x, y;
  Point() : x(0), y(0) {};
};

double square(Point *source, int n) {
  double x, y, x0, y0, S = 0;

  double xl = x0 = source[0].x;                    // (x0, y0) - кординаты первой вершины -
  double yl = y0 = source[0].y;                    // понадобятся для поиска площади под последней стороной

  for (int i = 1; i < n; i++) {
    x = source[i].x, y = source[i].y;       // Находим ориентированную площадь под стороной (xl, yl ; x, y), где
    S += midline(yl, y) * (x - xl);         // {xl, yl} - координаты предыдущей вершины, {x, y} - текущей
    xl = x;                                 // Если {x, y} лежит левее {xl, yl}, в силу обхода по часовой стрелке и выпуклости
    yl = y;                                 // площадь будет отрицательна (действительно, под такой стороной лежит только область,
  }                                         // не принадлежащая фигуре)

  S += midline(y, y0) * (x0 - x);           // Добавляем ориентированную площадь под последней гранью

  return S;                                 // Таким образом, M(n) = O(1), T(n) = O(n)
}

int main(int argc, char **argv) {
  int n = 0;
  double x, y;
  std::cin >> n;

  Point *arr = new Point[n];

  for (int i = 0; i < n; i++) {
    std::cin >> x >> y;
    arr[i].x = x;
    arr[i].y = y;
  }

  std::cout << square(arr, n);

  delete[] arr;

}